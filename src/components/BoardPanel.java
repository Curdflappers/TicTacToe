/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package components;

import config.Game;
import config.HumanPlayer;
import config.OPiece;
import config.Piece;
import config.Player;
import config.XPiece;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import src.Board;
import src.Line;
import src.Position;

/**
 *
 * @author mwwie
 */
public class BoardPanel extends javax.swing.JPanel {

    /**
     * The board this references
     */
    private final Board BOARD;
    
    /**
     * The thickness of the lines relative to the size of the position
     * Clamped between 0 and 1
     */
    public final double THICKNESS = 0.1;
    
    /**
     * The extension of the lines past the center
     * Clamped between 0 and 1
     */
    private double extension;
    
    /**
     * Width and height of this component
     */
    private final int SIZE = 500;
    
    /**
     * The amount of space left for a piece
     * Decreases based on thickness
     */
    public final double EMPTY_FRAC;
    
    /**
     * The width and height of one position on this board
     */
    public final double POS_SIZE;
    
    public final Game GAME;
    
    private Position hoverPosition;
    
    /**
     * Creates new form BoardPanel
     * @param b the board this should reference
     */
    public BoardPanel(Game g) {
        initComponents();
        BOARD = g.getBoard();
        extension = 0.95;
        EMPTY_FRAC = (1-THICKNESS/2);
        POS_SIZE = SIZE / BOARD.getRows(); // width or height of one position
        setSize(SIZE, SIZE);
        GAME = g;
    }

    @Override
    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        // drawBorder(g);
        drawLines(g);
        drawHoverPiece(g);
        drawPlayedPieces(g);
        drawWinLine(g);
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        if(GAME.getCurrentPlayer() instanceof HumanPlayer)
        {
            int c = (int)(evt.getX()/POS_SIZE);
            int r = (int)(evt.getY()/POS_SIZE);
            GAME.play(new Position(r, c));
        }
        repaint();
    }//GEN-LAST:event_formMouseClicked

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        hoverPosition = new Position(
                (int)(evt.getY()/POS_SIZE),
                (int)(evt.getX()/POS_SIZE));
        repaint();
    }//GEN-LAST:event_formMouseMoved

    /**
     * Draws the lines of the board with respect to thickness and extension
     * @param g the graphics object to draw the lines with
     */
    private void drawLines(Graphics g) {
        
        int vertX = (int)(POS_SIZE * EMPTY_FRAC);
        int vertY = (int)(POS_SIZE * (1 - extension) * EMPTY_FRAC);
        int lineThickness = (int)(POS_SIZE * THICKNESS);
        int lineLength = 
                (int)(POS_SIZE * (2 * extension * EMPTY_FRAC + THICKNESS + 1));
        
        g.setColor(Color.BLACK);
        
        // vertical rectangles
        g.fillRect(vertX,                 vertY, lineThickness, lineLength);
        g.fillRect(vertX + (int)POS_SIZE, vertY, lineThickness, lineLength);
        
        // horizontal rectangles
        g.fillRect(vertY, vertX,                 lineLength, lineThickness);
        g.fillRect(vertY, vertX + (int)POS_SIZE, lineLength, lineThickness);
    }

    /**
     * Draws the pieces of this board
     * @param g 
     */
    private void drawPlayedPieces(Graphics g) {
        // TODO: Get the pieces from the board. For now, use red X and blue O
        Piece[] pieces = new Piece[2];
        pieces[0] = new XPiece(Color.red);
        pieces[1] = new OPiece(Color.blue);
        
        for(int r = 0; r < BOARD.getRows(); r++) {
            for(int c = 0; c < BOARD.getCols(); c++) {
                Position pos = new Position(r, c);
                int ownerIndex = BOARD.get(pos);
                if(ownerIndex != 0)
                {
                    Piece piece = pieces[ownerIndex - 1];
                    piece.drawAt(pos, g, this, true);
                }
            }
        }
    }

    /**
     * If necessary, draw the line connecting the winner's pieces, showing how
     * the winner won
     */
    private void drawWinLine(Graphics g) {
        int winner = BOARD.getWinner();
        if(winner == 1 || winner == 2)
        {
            Line winLine = BOARD.getWinLine();
            Player winPlayer = winner == 1 ? 
                    Game.game.getPlayer1() : Game.game.getPlayer2();
            Position head = winLine.getStart();
            Position tail = winLine.getPositions()[winLine.getLength() - 1];
            
            // swap to be sure head is in top or left position
            if(head.compareTo(tail) > 0) // head currently bottom or right
            {
                Position temp = head;
                head = tail;
                tail = temp;
            } // head now top or left
            
            // get top-left coordinates for each pos
            int xHead = coord(head, true);
            int yHead = coord(head, false);
            int xTail = coord(tail, true);
            int yTail = coord(tail, false);
            int emptySize = (int)(POS_SIZE * EMPTY_FRAC);
            int thickness = emptySize / 3;
            
            // set the color to be slightly darker than the player color
            g.setColor(winPlayer.getPiece().getColor().darker());
            
            // draw the circles for the rounded edges
            g.fillArc(xHead, yHead, thickness, thickness, 0, 360);
            g.fillArc(xTail, yTail, thickness, thickness, 0, 360);
            
            // fill the in-between line
            double sqrt2 = Math.sqrt(2.0);
            int xTL = 0; // the top-left x coord of the polyline
            int xTR = 0; // top-right
            int xBR = 0; // bottom-right
            int xBL = 0; // bottom-left
            int yTL = 0;
            int yTR = 0;
            int yBR = 0;
            int yBL = 0;
            
            if(head.col() == tail.col()) { // vertical line
                int dXR = thickness; // change for x-right variables
                int dY = thickness / 2; // for all y vars
                xTL = xHead;
                xTR = xHead + dXR;
                xBR = xHead + dXR;
                xBL = xHead;
                yTL = yHead + dY;
                yTR = yHead + dY;
                yBR = yTail + dY;
                yBL = yTail + dY;
            } else if (head.row() == tail.row()) { // horizontal line
                int dX = thickness / 2; // for all x vars
                int dYB = thickness; // for y-bottom vars
                xTL = xHead + dX;
                xTR = xTail + dX;
                xBR = xTail + dX;
                xBL = xHead + dX;
                yTL = yHead;
                yTR = yHead;
                yBR = yHead + dYB;
                yBL = yHead + dYB;
            } else { // diagonal line, head at top
                // TODO this method is oh-so-close
                // actually draw line in TL-BR win
                int dCenter = thickness / 2; // to get to center
                int offset = (int)(thickness / (2*sqrt2)); // necessary
                // this sets it for a TR-BL win
                xTL = xHead + dCenter - offset;
                xTR = xHead + dCenter + offset;
                xBR = xTail + dCenter + offset;
                xBL = xTail + dCenter - offset;
                yTL = yHead + dCenter + offset;
                yTR = yHead + dCenter - offset;
                yBR = yTail + dCenter - offset;
                yBL = yTail + dCenter + offset;
                if(head.col() > tail.col())
                {
                    yTL -= 2*offset;
                    yTR += 2*offset;
                    yBR += 2*offset;
                    yBL -= 2*offset;
                }
            }
            
            int[] xArr = new int[]{xTL, xTR, xBR, xBL};
            int[] yArr = new int[]{yTL, yTR, yBR, yBL};
            g.fillPolygon(xArr, yArr, 4);
        }
    }
    
    /**
     * Returns the top-left coordinate of the winLine for the given position
     * @param pos the position
     * @param x whether to return x or y coordinate (true for x, false for y)
     * @return the top-left coordinate of the winLine for the given position
     */
    private int coord(Position pos, boolean x)
    {
        return (int)(POS_SIZE * (
                (x ? pos.col() : pos.row()) + THICKNESS / 2 + EMPTY_FRAC / 3));
    }

    private void drawHoverPiece(Graphics g) {
        if(GAME.getCurrentPlayer() instanceof HumanPlayer 
                && BOARD.getEmptyPositions().contains(hoverPosition))
        {
            GAME.getCurrentPlayer().getPiece().drawAt(hoverPosition,
                    g, this, false);
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
